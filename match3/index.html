<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ruby app</title>  
    <script src="js/jquery.min.js"></script>
    <script src="js/opal.min.js"></script>
    <script src="js/opal-parser.min.js"></script>
    <script src="js/native.min.js"></script>
    <script src="js/opal-jquery-0.4.2.js"></script>
    <script src="js/opal-browser-0.2.0.js"></script>
    <script type="text/javascript">Opal.load('opal-parser')</script>  
    <script type="text/ruby">
class Program
  def initialize()
    @next = ""
    @output = ""
    @input = ""
    @ok = true
    # Game state
    @field = Array.new(HEIGHT) { Array.new(WIDTH) { 0 } }
    @points = 0
    @select_row = 0
    @select_col = 0
  end

  def refresh()
    Element['.content'].html = @output
  end

  def puts(*args)
    res = ""
    for i in args
      res += i.to_s
    end
    @output += "\n" + res

    refresh()
    #Kernel.puts(*args)
  end

  def gets()
    @ok = false
    #@input = Kernel.gets
  end

  # Constants:
  HEIGHT = 5
  WIDTH = 5
  COLOURS = [1, 2, 3, 4, 5]
  DIR = ["r", "l", "u", "d"]
  MIN_NEIGHBOURS = 2

  def clear_screen()
    # @output = ""
    # refresh()
    # puts("\n" * 50)
  end

  # Prints a field and points.
  def puts_field(field, points)
    i = 1
    res = "column  "
    for x in 1..WIDTH
      res += x.to_s
      res += "  "
    end
    res += "    points\n      "
    for x in 0..WIDTH-1
      res += " .."
    end
    res += "      "
    res += points.to_s
    res += "\nrow "
    for row in field
      if i > 1 then res += "    " end
      res += i.to_s
      res += ":  "
      i += 1
      for x in row
        res += x.to_s
        res += "  "
      end
      res += "\n"
    end
    res += "\n"
    puts(res)
  end

  # Gets all deletions for the field as a self-explanatory list of lists.
  # A deletion has this structure ["row" | "column", index, "...", start, "...", count].
  # The returned deletion list may be empty.
  def get_deletions(field)
    deletions = []
    for x in 0..WIDTH-1
      following = 0
      start = 0
      for y in 0..HEIGHT-2
        if field[y][x] == field[y+1][x]
          following += 1
        elsif following < MIN_NEIGHBOURS
          following = 0
          start = y+1
        end
      end
      if following >= MIN_NEIGHBOURS
        deletions += [["column", x, "deleting row starting at", start, "with neighbours", following]]
      end
    end

    for y in 0..HEIGHT-1
      following = 0
      start = 0
      for x in 0..WIDTH-2
        if field[y][x] == field[y][x+1]
          following += 1
        elsif following < MIN_NEIGHBOURS
          following = 0
          start = x+1
        end
      end
      if following >= MIN_NEIGHBOURS
        deletions += [["row", y, "deleting column starting at", start, "with neighbors", following]]
      end
    end
    #puts("\n")
    deletions
  end

  # Executes the deletions by setting deleted values to 0.
  def exec_deletions(field, deletions)
    for deletion in deletions
      start = deletion[3]
      count = deletion[5]
      if deletion.first == "row"
        y = deletion[1]
        for x in start..start+count
          field[y][x] = 0
        end
      elsif deletion.first == "column"
        x = deletion[1]
        for y in start..start+count
          field[y][x] = 0
        end
      end
    end
  end

  # lets all numbers fall down (0 denotes an empty field)
  def fall_down(field)
    for x in 0..WIDTH-1
      for y in (HEIGHT-1).downto 0
        if field[y][x] == 0
          #puts("At ", y, ",", x, " == 0, above:\n")
          for index in (y-1).downto 0
            elem = field[index][x]
            if elem != 0
              field[y][x] = elem
              field[index][x] = 0
              break
            end
            #puts(elem, " at (", index, ",", x, ") ")
          end
          #puts("\n")
        end
      end
    end
  end

  # Replaces all 0s with random elements from COLOURS.
  def refill(field)
    for y in 0..HEIGHT-1
      for x in 0..WIDTH-1
        if field[y][x] == 0
          field[y][x] = COLOURS[rand(COLOURS.length)]
        end
      end
    end
    #puts("\n")
  end

  # Gets the neighbor index as [y, x].
  # Returns "invalid" if an invalid direction was passed.
  # Returns nil if the resulting index were outside.
  def index_near(select_row, select_col, direction)
    if !DIR.member? direction
      "invalid"
    elsif direction == DIR[0] && select_col + 1 < WIDTH
      [select_row, select_col + 1]
    elsif direction == DIR[1] && select_col - 1 >= 0
      [select_row, select_col - 1]
    elsif direction == DIR[2] && select_row - 1 >= 0
      [select_row - 1, select_col]
    elsif direction == DIR[3] && select_row + 1 < HEIGHT
      [select_row + 1, select_col]
    end
  end

  # Checks if there are any possible moves.
  # Returns a possible move as [y, x, dir] or nil if there are none.
  def no_more_moves(field)
    for row in 0..HEIGHT-1
      for col in 0..HEIGHT-1
        for direction in DIR
          pair = index_near row, col, direction
          if !pair.nil?
            swap_fields(field, row, col, pair[0], pair[1])
            list = get_deletions(field)
            swap_fields(field, pair[0], pair[1], row, col)
            if !list.empty?
              return [row, col, direction]
            end
          end
        end
      end
    end
    nil
  end

  # Swaps two items in the field by passing their indices.
  def swap_fields(field, select_row, select_col, neighbour_row, neighbour_col)
    temp = field[select_row][select_col]
    field[select_row][select_col] = field[neighbour_row][neighbour_col]
    field[neighbour_row][neighbour_col] = temp
  end

  # Deletes all matches in the field, keeping their score.
  # Then let elements fall down and replaces them.
  # Returns the points gotten by deletions during this process.
  def delete_and_refill(field)
    points = 0
    done = false
    while !done
      deletions = get_deletions(field)
      for delition in deletions
        points += 1 + delition[5]
      end
      exec_deletions(field, deletions)
      fall_down(field)
      refill(field)
      done = deletions.empty?
      #puts(".")
    end
    points
  end

  def main()
    puts("Welcome to match3 (broxp.github.com/match3), a ruby app in your browser (using opal).\n")
    puts("The target is to gain points by matching 3 or more numbers of the same value.\n")
    puts("You will see the field displayed and select a row and column as well as a direction.\n")
    puts("Then, the fields are swapped and 3 or more neighbours will disappear gaining you points.\n")
    puts("Directions are: r for right, l for left, u for up and d for down.\n")
    puts("The game will end if there are no more valid moves.\n")
    puts("Entering ? when asked for a row will show a hint. Good luck!\n")
    puts("\n")

    # Useful testing samples:
    # delete_t_shape = [
    #     [2,6,6,6,1],
    #     [2,5,5,5,5],
    #     [7,7,7,2,1],
    #     [1,8,5,2,1],
    #     [3,3,2,2,2]
    # ]
    #
    # no_moves = [
    #     [2,3,1,2,4],
    #     [1,5,5,4,2],
    #     [1,2,1,3,1],
    #     [2,4,5,4,1],
    #     [3,3,2,5,2]
    # ]

    # Initialize
    refill(@field)
    ignore = delete_and_refill(@field)
    puts_field(@field, @points)

    @next = "main_loop"
  end

  def input_loop2()
    row_str = @input.chomp
    @select_row = row_str.to_i - 1
    if row_str == "?"
      puts("Hint: #{@pos[0] + 1}, #{@pos[1] + 1}, #{@pos[2]}\n")
      @next = "main_loop"
    elsif not 0 <= @select_row && @select_row < HEIGHT
      puts("invalid choice (expecting a number from 1 to #{HEIGHT})\n")
      @next = "main_loop"
    else
      puts("Column> ")
      gets
      @next = "input_loop3"
    end
  end

  def input_loop4()
    direction = @input.chomp
    field = @field
    points = @points

    neighbor_pos = index_near(@select_row, @select_col, direction)
    if neighbor_pos == "invalid"
      puts("invalid choice (valid directions are r, l, u or d)\n")
      @next = "main_loop"
    elsif neighbor_pos.nil?
      puts("invalid choice (neighbour is out of field)\n")
      @next = "main_loop"
    else
      swap_fields(field, @select_row, @select_col, neighbor_pos[0], neighbor_pos[1])
      #puts_field(sample)
      deletions = get_deletions(field)
      if deletions.empty?
        swap_fields(field, neighbor_pos[0], neighbor_pos[1], @select_row, @select_col)
        puts("invalid choice (will not result in match)\n")
        @next = "main_loop"
      else
        # Score points
        points += delete_and_refill(field)
        @points = points
        # Clear and redraw
        clear_screen
        puts_field(field, points)
        @next = "main_loop"
      end
    end
  end

  def input_loop3()
    @select_col = @input.chomp.to_i - 1
    if not 0 <= @select_col && @select_col < WIDTH
      puts("invalid choice (expecting a number from 1 to #{HEIGHT})\n")
      @next = "main_loop"
    else
      puts("Direction> ")
      gets
      @next = "input_loop4"
    end
  end

  def nop()
    puts("nothing to do")
  end

  def main_loop()
    field = @field
    @pos = no_more_moves(field)
    if @pos.nil?
      puts("There are no more moves. Thank you for playing.\n")
    else
      # Input processing
      puts("Row> ")
      gets
      @next = "input_loop2"
    end
  end

  def use_input()
    Element['.input'].value = ""
    Element['.input'].focus()
    `window.scrollTo(0, document.body.scrollHeight)`
    # $window.to(0, Element['body'][0].scroll_height)
  end

  def input_done(value)
    @input = value
    @ok = true
    @output += @input + "\n"
    refresh()
    # Execute code while no input needed
    while @ok
      eval(@next)
    end
    use_input()
  end

  def method_missing(proc, *args)
    puts("Fehler: #{proc} #{proc.class} #{args.length} #{args} #{$err} #{$_}")
    raise("Missing: " + proc)
  end
end

Document.ready? do
  prog = Program.new()
  input_elem = Element['.input']
  input_elem.on(:keyup) do |event|
    if(event.key_code == 13)
      prog.input_done(input_elem.value)
    end
  end
  Element['.ok'].on(:click) do |event|
    prog.input_done(input_elem.value)
  end

  prog.main()
  prog.input_done(input_elem.value)
end
    </script>
  </head>
  <body>
    <pre class="content">
loading jquery and opal...
    </pre>
    <input class="input" type="text" />
    <input class="ok" type="submit" />
  </body>
</html>
